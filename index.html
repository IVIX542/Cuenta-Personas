<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Contador de Personas 3D</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js CDN (Versión r128) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls CDN (Para mover la cámara con el ratón/touch) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        /* Estilos personalizados para asegurar que el lienzo 3D ocupe la pantalla */
        #scene-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background-color: #111122; 
        }
        canvas {
            display: block;
        }
    </style>
    <script>
        // Configuración de Tailwind para usar la fuente Inter
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
</head>
<body class="font-sans antialiased">

    <div id="scene-container">
        <!-- El canvas de Three.js se insertará aquí -->
        
        <!-- Controles de la Interfaz de Usuario -->
        <div id="controls" class="absolute top-4 left-1/2 transform -translate-x-1/2 p-4 bg-white bg-opacity-90 rounded-xl shadow-2xl z-10 w-11/12 max-w-2xl flex flex-wrap justify-center space-x-2 space-y-2 sm:space-y-0 border border-gray-100">
            <button id="addMan" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200 shadow-md active:shadow-inner min-w-[120px]">
                Añadir Hombre
            </button>
            <button id="addWoman" class="flex-1 bg-pink-600 hover:bg-pink-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200 shadow-md active:shadow-inner min-w-[120px]">
                Añadir Mujer
            </button>
            <!-- Botón para limpiar todo, ahora coordinado -->
            <button id="clearAll" class="flex-1 bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200 shadow-md active:shadow-inner min-w-[120px]">
                Limpiar Todo
            </button>
        </div>

        <!-- Lista de Personas Añadidas -->
        <div class="absolute bottom-4 right-4 p-4 bg-white bg-opacity-90 rounded-xl shadow-2xl z-10 w-full max-w-xs border border-gray-100">
            <h3 class="text-lg font-bold mb-2 text-gray-800">Personas en Escena (<span id="count">0</span>)</h3>
            <ul id="peopleList" class="max-h-40 overflow-y-auto space-y-2">
                <!-- Los elementos de la lista se insertarán aquí -->
            </ul>
        </div>
        
    </div>

    <script type="module">
        // Variables globales de Three.js
        let scene, camera, renderer, controls;
        // Mapa para almacenar los objetos de persona y su estado
        const people = new Map();
        let lastTimestamp = 0;
        const LOOK_INTERVAL = 3000; // Intervalo para mirar aleatoriamente (en ms)
        const WALK_SPEED = 0.003; // Velocidad de caminata
        const DANCE_SPEED = 0.002; // Velocidad de animación de baile

        // --- Lógica de Salida Coordinada ---
        let isGlobalRemovalActive = false; 
        let exitOrderIds = []; 

        // --- Configuración del Club ---
        const CLUB_SIZE = 15; 
        const DOOR_POSITION = new THREE.Vector3(-CLUB_SIZE / 2 - 0.05, 0, 0); 
        const DOOR_ROTATION = Math.PI / 2; 
        let mainDoorMesh; 

        // Elementos del DOM
        const peopleListElement = document.getElementById('peopleList');
        const countElement = document.getElementById('count');
        const sceneContainer = document.getElementById('scene-container');

        // --- CONSTANTES DE PROPORCIÓN DE CUERPO ---
        const PERSON_HEIGHT = 1.8;
        const HEAD_RADIUS = 0.25;
        const TORSO_HEIGHT = 0.6;
        const TORSO_RADIUS = 0.25;
        const LIMB_THICKNESS = 0.1;
        const LEG_HEIGHT = PERSON_HEIGHT - HEAD_RADIUS * 2 - TORSO_HEIGHT; 
        const ARM_LENGTH = 0.6;


        /**
         * Crea las paredes del club.
         */
        function createWalls(size) {
            const wallHeight = 4;
            const wallThicknessInner = 0.1;
            const wallMaterialInterior = new THREE.MeshLambertMaterial({ color: 0x444444 });
            const innerRadius = size / 2 + wallThicknessInner / 2;
            const doorGapWidth = 1.2; 
            const sideSegmentLength = (size - doorGapWidth) / 2;
            const createWallSegment = (width, depth, x, z, material) => {
                const geometry = new THREE.BoxGeometry(width, wallHeight, depth);
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, wallHeight / 2, z);
                return mesh;
            };

            scene.add(createWallSegment(size + wallThicknessInner * 2, wallThicknessInner, 0, -innerRadius, wallMaterialInterior));
            scene.add(createWallSegment(wallThicknessInner, size + wallThicknessInner * 2, innerRadius, 0, wallMaterialInterior));
            scene.add(createWallSegment(size + wallThicknessInner * 2, wallThicknessInner, 0, innerRadius, wallMaterialInterior));
            
            const xInner = -innerRadius;
            scene.add(createWallSegment(wallThicknessInner, sideSegmentLength + wallThicknessInner * 2, xInner, -sideSegmentLength / 2 - doorGapWidth / 2, wallMaterialInterior));
            scene.add(createWallSegment(wallThicknessInner, sideSegmentLength + wallThicknessInner * 2, xInner, sideSegmentLength / 2 + doorGapWidth / 2, wallMaterialInterior));
        }

        /**
         * Crea la geometría del pelo con cobertura COMPLETA para la cabeza.
         */
        function createHair(headRadius, hairColor, styleId) {
            const hairMaterial = new THREE.MeshLambertMaterial({ color: hairColor });
            const hairGroup = new THREE.Group();
            
            // --- BASE DE COBERTURA COMPLETA ---
            const baseGeo = new THREE.SphereGeometry(headRadius * 1.05, 16, 16);
            const baseHair = new THREE.Mesh(baseGeo, hairMaterial);
            baseHair.position.y = headRadius * 0.1; 
            hairGroup.add(baseHair); 

            // --- DETALLES DE ESTILO ---
            switch (styleId) {
                case 'long_ponytail':
                    // Cola de Caballo (cilindro delgado)
                    const tailGeo = new THREE.CylinderGeometry(0.15, 0.25, 0.8, 8);
                    const tail = new THREE.Mesh(tailGeo, hairMaterial);
                    tail.rotation.x = Math.PI / 2;
                    tail.position.set(0, -0.2, -headRadius * 1.2); 
                    hairGroup.add(tail);
                    break;
                case 'wavy_bob':
                    // Volumen superior y lateral
                    const bobCapGeo = new THREE.SphereGeometry(
                        headRadius * 1.05, 16, 16, 0, Math.PI * 2, 0, Math.PI * 0.75 
                    );
                    const bobCap = new THREE.Mesh(bobCapGeo, hairMaterial);
                    bobCap.rotation.x = Math.PI / 2;
                    bobCap.position.y = headRadius * 0.3;
                    hairGroup.add(bobCap);
                    break;
                case 'curly_volume':
                    hairGroup.remove(baseHair); 
                    const volumeGeo = new THREE.SphereGeometry(headRadius * 1.3, 12, 12);
                    const volumeHair = new THREE.Mesh(volumeGeo, hairMaterial);
                    volumeHair.position.y = headRadius * 0.4;
                    hairGroup.add(volumeHair);
                    break;
                case 'short_crop':
                default:
                    const topVolumeGeo = new THREE.SphereGeometry(
                        headRadius * 0.8, 16, 16, 0, Math.PI * 2, 0, Math.PI * 0.5 
                    ); 
                    const topVolume = new THREE.Mesh(topVolumeGeo, hairMaterial);
                    topVolume.rotation.x = Math.PI / 2;
                    topVolume.position.y = headRadius * 0.5;
                    hairGroup.add(topVolume);
                    break;
            }

            return hairGroup;
        }

        /**
         * Crea un brazo o una pierna articulada.
         * CORRECCIÓN: Se añade 'userData.isLimb = true' para una fácil identificación en createBouncer.
         * @param {number} length Longitud de la extremidad.
         * @param {number} thickness Grosor.
         * @param {THREE.Color} color Color del material.
         * @returns {THREE.Group} Grupo articulado (pivote en el hombro/cadera).
         */
        function createLimb(length, thickness, color) {
            const material = new THREE.MeshLambertMaterial({ color: color });
            const geometry = new THREE.BoxGeometry(thickness, length, thickness);
            const mesh = new THREE.Mesh(geometry, material);
            
            // Posicionar la malla para que el origen (pivot) del grupo esté en la articulación
            mesh.position.y = -length / 2; 
            
            const limbGroup = new THREE.Group();
            limbGroup.userData.isLimb = true; // CORRECCIÓN: Marca el grupo como extremidad
            limbGroup.add(mesh);
            return limbGroup;
        }

        /**
         * Crea el modelo 3D de una persona con extremidades articuladas.
         */
        function createPerson(gender) {
            const isMan = gender === 'man';
            const bodyColor = isMan ? 0x1f78b4 : 0xfb923c; 
            const skinColor = 0xf8d7c4;
            const hairColors = [0x3a281c, 0x000000, 0xdfc181, 0x8b4513, 0xaa2222]; 
            const hairColor = hairColors[Math.floor(Math.random() * hairColors.length)];
            
            const personGroup = new THREE.Group();
            personGroup.userData.gender = gender;
            
            // --- 1. TORSO (CUERPO) ---
            const bodyGeometry = new THREE.CylinderGeometry(TORSO_RADIUS, TORSO_RADIUS, TORSO_HEIGHT, 8);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: bodyColor });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            // El torso se sienta sobre las piernas (que empiezan en y=0, por lo que su centro está en LEG_HEIGHT + TORSO_HEIGHT/2)
            body.position.y = LEG_HEIGHT + TORSO_HEIGHT / 2; 
            personGroup.add(body);
            personGroup.userData.body = body;

            // --- 2. CABEZA ---
            const headGeometry = new THREE.SphereGeometry(HEAD_RADIUS, 16, 16);
            const headMaterial = new THREE.MeshLambertMaterial({ color: skinColor });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            // La cabeza se coloca sobre el torso
            head.position.y = LEG_HEIGHT + TORSO_HEIGHT + HEAD_RADIUS; 
            
            // Cabello
            let hairStyleId;
            if (isMan) {
                hairStyleId = Math.random() < 0.8 ? 'short_crop' : 'curly_volume'; 
            } else {
                const rand = Math.random();
                if (rand < 0.4) hairStyleId = 'wavy_bob';
                else if (rand < 0.8) hairStyleId = 'long_ponytail';
                else hairStyleId = 'curly_volume';
            }
            const hairMesh = createHair(HEAD_RADIUS, hairColor, hairStyleId);
            head.add(hairMesh);
            
            // Ojos (agrupados en la cabeza)
            const eyeGeometry = new THREE.CircleGeometry(0.05, 8); 
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const eyeL = new THREE.Mesh(eyeGeometry, eyeMaterial);
            eyeL.position.set(-0.1, 0.0, HEAD_RADIUS); 
            const eyeR = new THREE.Mesh(eyeGeometry, eyeMaterial);
            eyeR.position.set(0.1, 0.0, HEAD_RADIUS); 
            
            const faceGroup = new THREE.Group();
            faceGroup.add(eyeL, eyeR);
            faceGroup.position.z = HEAD_RADIUS - 0.01; 
            head.add(faceGroup);
            personGroup.add(head);
            personGroup.userData.head = head;


            // --- 3. EXTREMIDADES INFERIORES (PIERNAS) ---
            const legColor = isMan ? bodyColor : 0x555555; // Pantalones más oscuros
            
            // Pierna Izquierda (PI)
            const legLGroup = createLimb(LEG_HEIGHT, LIMB_THICKNESS * 1.5, legColor);
            legLGroup.position.set(-TORSO_RADIUS / 2, LEG_HEIGHT, 0); // Posición de la cadera
            personGroup.add(legLGroup);
            personGroup.userData.legL = legLGroup;

            // Pierna Derecha (PD)
            const legRGroup = createLimb(LEG_HEIGHT, LIMB_THICKNESS * 1.5, legColor);
            legRGroup.position.set(TORSO_RADIUS / 2, LEG_HEIGHT, 0); 
            personGroup.add(legRGroup);
            personGroup.userData.legR = legRGroup;


            // --- 4. EXTREMIDADES SUPERIORES (BRAZOS) ---
            const armColor = bodyColor;
            
            // Brazo Izquierdo (BI)
            const armLGroup = createLimb(ARM_LENGTH, LIMB_THICKNESS, armColor);
            // Posición del hombro (y: parte superior del torso - un poco hacia abajo, x: lateral)
            armLGroup.position.set(-(TORSO_RADIUS + LIMB_THICKNESS / 2), LEG_HEIGHT + TORSO_HEIGHT - LIMB_THICKNESS, 0); 
            armLGroup.rotation.z = Math.PI / 2; // Colgar verticalmente
            personGroup.add(armLGroup);
            personGroup.userData.armL = armLGroup;

            // Brazo Derecho (BD)
            const armRGroup = createLimb(ARM_LENGTH, LIMB_THICKNESS, armColor);
            armRGroup.position.set((TORSO_RADIUS + LIMB_THICKNESS / 2), LEG_HEIGHT + TORSO_HEIGHT - LIMB_THICKNESS, 0); 
            armRGroup.rotation.z = -Math.PI / 2; 
            personGroup.add(armRGroup);
            personGroup.userData.armR = armRGroup;

            personGroup.userData.creationTime = Date.now(); 

            return personGroup;
        }

        /**
         * Crea el modelo 3D del Portero (Bouncer) con extremidades.
         */
        function createBouncer() {
            const suitColor = 0x111111; 
            const hairColor = 0x000000; 
            const BOUNCER_SCALE = 1.1; 
            
            const bouncerGroup = createPerson('man');
            
            bouncerGroup.scale.set(BOUNCER_SCALE, BOUNCER_SCALE, BOUNCER_SCALE);
            bouncerGroup.userData.gender = 'bouncer';
            
            // Recolorar para traje de portero
            bouncerGroup.traverse((object) => {
                if (object.isMesh && object.material.isMeshLambertMaterial) {
                    // CORRECCIÓN: Usar la marca 'isLimb' en el grupo padre.
                    if (object.parent.userData.isLimb) { // Extremidades (cajas dentro de grupos articulados)
                        object.material.color.set(suitColor);
                    } else if (object.geometry.type === 'CylinderGeometry') { // Torso
                        object.material.color.set(suitColor);
                    } 
                }
            });
            
            // Asignar Cabello Fijo
            const head = bouncerGroup.userData.head;
            while(head.children.length > 0) { head.remove(head.children[0]); } // Eliminar pelo anterior
            const hairMesh = createHair(HEAD_RADIUS, hairColor, 'short_crop');
            head.add(hairMesh);

            return bouncerGroup;
        }

        /**
         * Inicializa la escena 3D, la cámara, el renderizador y los controles.
         */
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111122); 

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(-10, 8, 10); 
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            sceneContainer.appendChild(renderer.domElement);

            // Luces (Ambiente tenue y luces de fiesta)
            const hemisphereLight = new THREE.HemisphereLight(0x444466, 0x000000, 0.6); 
            scene.add(hemisphereLight);
            
            const discoLight = new THREE.PointLight(0xFFFFFF, 3.5, 15, 2); 
            discoLight.position.set(CLUB_SIZE / 3, 3, CLUB_SIZE / 3); 
            scene.add(discoLight);
            scene.userData.discoLight = discoLight;

            const centralSpotLight = new THREE.PointLight(0xFFFFFF, 1.2, CLUB_SIZE * 0.8); 
            centralSpotLight.position.set(0, 3.5, 0);
            scene.add(centralSpotLight);

            // Luces Exteriores
            const doorLightColor = 0xffdd88; 
            const lightIntensity = 1.0; 

            const doorLightL = new THREE.SpotLight(doorLightColor, lightIntensity, 4, Math.PI / 4, 0.5, 2);
            doorLightL.position.set(DOOR_POSITION.x + 1.5, 3.0, DOOR_POSITION.z - 1.0);
            doorLightL.target.position.set(DOOR_POSITION.x, 1.5, DOOR_POSITION.z - 0.5); 
            scene.add(doorLightL);
            scene.add(doorLightL.target);
            
            const doorLightR = new THREE.SpotLight(doorLightColor, lightIntensity, 4, Math.PI / 4, 0.5, 2);
            doorLightR.position.set(DOOR_POSITION.x + 1.5, 3.0, DOOR_POSITION.z + 1.0);
            doorLightR.target.position.set(DOOR_POSITION.x, 1.5, DOOR_POSITION.z + 0.5); 
            scene.add(doorLightR);
            scene.add(doorLightR.target);

            // Controles de Órbita 
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; 
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 2;
            controls.maxDistance = 50;
            controls.maxPolarAngle = Math.PI / 2; 

            // Suelo (Oscuro y Reflectante para ambiente disco)
            const floorGeometry = new THREE.PlaneGeometry(CLUB_SIZE * 1.5, CLUB_SIZE * 1.5); 
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333, 
                metalness: 0.5, 
                roughness: 0.3, 
                side: THREE.DoubleSide 
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = 0;
            floor.receiveShadow = true; 
            scene.add(floor);
            
            // Paredes 
            createWalls(CLUB_SIZE);

            // Puerta Fija
            mainDoorMesh = createDoor();
            mainDoorMesh.position.copy(DOOR_POSITION);
            mainDoorMesh.rotation.y = DOOR_ROTATION; 
            scene.add(mainDoorMesh);
            
            // Portero Fijo
            const bouncer = createBouncer();
            bouncer.position.set(DOOR_POSITION.x - 0.5, 0, 1.2); 
            bouncer.rotation.y = Math.PI * 0.55; 
            scene.add(bouncer);

            // Fila de Espera (Queue)
            createQueue(4); 

            // Lámpara de calle exterior
            createStreetLamp(); 
            
            // Decoración Interior
            createDecoration();

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            document.getElementById('addMan').addEventListener('click', () => addPerson('man'));
            document.getElementById('addWoman').addEventListener('click', () => addPerson('woman'));
            document.getElementById('clearAll').addEventListener('click', clearAllPeople); 

            // Iniciar el bucle de animación
            animate();
        }

        /**
         * Añade una nueva persona a la escena.
         */
        function addPerson(gender) {
            if (isGlobalRemovalActive) return;
            
            const id = THREE.MathUtils.generateUUID();
            const personMesh = createPerson(gender);

            const x = THREE.MathUtils.randFloatSpread(CLUB_SIZE * 0.8);
            const z = THREE.MathUtils.randFloatSpread(CLUB_SIZE * 0.8);
            personMesh.position.set(x, 0, z);

            people.set(id, {
                id: id,
                mesh: personMesh,
                gender: gender,
                isRemoving: false,
                removalState: 0, 
                doorMesh: mainDoorMesh, 
                doorPosition: null, 
                targetLookRotation: new THREE.Vector3(0, personMesh.rotation.y, 0),
                lastLookTime: performance.now(), 
                targetRotation: 0,
            });

            scene.add(personMesh);
            updateUI();
        }

        /**
         * Lógica para iniciar el proceso de eliminación (animación de salida) para una persona.
         */
        function removePersonSetup(id) { 
            const personState = people.get(id);
            if (!personState || personState.isRemoving) return;

            personState.isRemoving = true;
            personState.removalState = 1; 

            const personPos = personState.mesh.position;
            
            const doorPos = mainDoorMesh.position.clone();
            const offset = 0.5; 
            doorPos.x += offset; 
            
            personState.doorPosition = doorPos;

            const directionToDoor = new THREE.Vector3().subVectors(personState.doorPosition, personPos).normalize();
            personState.targetRotation = Math.atan2(directionToDoor.x, directionToDoor.z);
        }

        /**
         * Aplica la animación de baile a una persona.
         * @param {THREE.Group} mesh La malla principal de la persona.
         * @param {number} time El tiempo actual para el ciclo.
         */
        function applyDanceAnimation(mesh, time) {
            const freq = time * DANCE_SPEED * 1.5;
            const sway = Math.sin(freq * 2.5) * 0.05;
            const bob = Math.cos(freq * 1.5) * 0.05;

            // Movimiento de cadera/cuerpo
            mesh.rotation.y = sway * 0.5;
            mesh.rotation.x = sway * 0.2;
            
            // Brazo y Pierna simple (opuesto)
            const armAngle = Math.sin(freq * 4) * 0.3; 
            mesh.userData.armL.rotation.x = armAngle;
            mesh.userData.armR.rotation.x = -armAngle;
            
            // Las piernas se mueven sutilmente para el ritmo
            const legAngle = Math.sin(freq * 4 + Math.PI/2) * 0.05;
            mesh.userData.legL.rotation.x = legAngle;
            mesh.userData.legR.rotation.x = -legAngle;

            // Movimiento de cabeza
            mesh.userData.head.position.y = (LEG_HEIGHT + TORSO_HEIGHT + HEAD_RADIUS) + bob;
        }

        /**
         * Aplica la animación de caminar a una persona.
         * @param {THREE.Group} mesh La malla principal de la persona.
         * @param {number} time El tiempo actual para el ciclo.
         * CORRECCIÓN: Se ajusta la velocidad del paso.
         */
        function applyWalkAnimation(mesh, time) {
            const stepFreq = time * 0.015 * 1.5; // Ajuste de frecuencia
            const stepAngle = Math.sin(stepFreq) * 0.4; // Ángulo de paso 
            
            // Brazos opuestos
            mesh.userData.armL.rotation.x = stepAngle;
            mesh.userData.armR.rotation.x = -stepAngle;

            // Piernas opuestas (desfasadas)
            mesh.userData.legL.rotation.x = -stepAngle; 
            mesh.userData.legR.rotation.x = stepAngle;

            // Movimiento de cuerpo sutil al caminar (subida/bajada)
            mesh.position.y = Math.abs(Math.sin(stepFreq * 0.5)) * 0.03; 
        }

        /**
         * Bucle principal de animación (Llamado 60 veces por segundo).
         */
        function animate(timestamp = 0) {
            requestAnimationFrame(animate);

            const deltaTime = timestamp - lastTimestamp;
            lastTimestamp = timestamp;

            controls.update(); 
            
            // Ciclo de color para la luz de disco
            if (scene.userData.discoLight) {
                const time = timestamp * 0.001;
                const color = new THREE.Color();
                color.setHSL(Math.sin(time * 0.3) * 0.5 + 0.5, 1, 0.7); 
                scene.userData.discoLight.color.copy(color);
            }


            people.forEach((state, id) => {
                const mesh = state.mesh;
                const head = mesh.userData.head;

                
                // --- A) Animación de Mirada / Baile (Idle) ---
                if (!state.isRemoving) { 
                    applyDanceAnimation(mesh, timestamp);

                    // Mirada aleatoria (solo en el eje Y de la cabeza)
                    if (timestamp - state.lastLookTime > LOOK_INTERVAL) { 
                        state.targetLookRotation.y = THREE.MathUtils.randFloat(-Math.PI * 0.1, Math.PI * 0.1);
                        state.lastLookTime = timestamp; 
                    }
                    head.rotation.y = THREE.MathUtils.lerp(head.rotation.y, state.targetLookRotation.y, 0.05);
                } else {
                    // Si está saliendo, restablecer la rotación de la cabeza (para que mire hacia adelante)
                    head.rotation.set(0,0,0);
                }

                // --- B) Animación de Eliminación (Removal) ---
                if (state.isRemoving) {
                    
                    // Estado 1: Girar hacia la Puerta
                    if (state.removalState === 1) {
                        const currentRotation = mesh.rotation.y;
                        
                        let diff = state.targetRotation - currentRotation;
                        if (diff > Math.PI) diff -= (2 * Math.PI);
                        if (diff < -Math.PI) diff += (2 * Math.PI);

                        const rotationStep = diff * 0.05; 
                        mesh.rotation.y += rotationStep;

                        if (Math.abs(diff) < 0.01) {
                            mesh.rotation.y = state.targetRotation;
                            state.removalState = 2; 
                        }
                        
                        // En espera, aplicar animación de brazos sueltos (sutil)
                        mesh.userData.armL.rotation.x = Math.sin(timestamp * 0.005) * 0.1;
                        mesh.userData.armR.rotation.x = -mesh.userData.armL.rotation.x;
                        mesh.userData.legL.rotation.x = 0;
                        mesh.userData.legR.rotation.x = 0;
                        mesh.position.y = 0; // Posición fija
                    } 
                    
                    // Estado 2: Caminar hacia la Puerta
                    else if (state.removalState === 2) {
                        applyWalkAnimation(mesh, timestamp); // Aplicar animación de caminata

                        const targetPos = state.doorPosition;
                        const currentPos = mesh.position;

                        currentPos.lerp(targetPos, WALK_SPEED * deltaTime);
                        
                        if (currentPos.distanceTo(targetPos) < 0.1) {
                            state.removalState = 3; 
                            // Restablecer posición de extremidades al finalizar el paso
                            mesh.position.y = 0;
                            mesh.userData.armL.rotation.x = 0;
                            mesh.userData.armR.rotation.x = 0;
                            mesh.userData.legL.rotation.x = 0;
                            mesh.userData.legR.rotation.x = 0;
                        }
                    } 
                    
                    // Estado 3: Abrir Puerta y Desaparecer
                    else if (state.removalState === 3) {
                        const doorHinge = state.doorMesh.userData.hinge;
                        
                        const targetRotation = Math.PI * 0.9; 
                        doorHinge.rotation.y = THREE.MathUtils.lerp(doorHinge.rotation.y, targetRotation, 0.05);

                        if (doorHinge.rotation.y > Math.PI * 0.2) {
                            applyWalkAnimation(mesh, timestamp); // Sigue caminando
                            mesh.translateZ(WALK_SPEED * deltaTime * 1.5); 
                        }
                        
                        if (mesh.position.x < -CLUB_SIZE / 2 - 1) { 
                            state.removalState = 4; 
                        }
                    }
                    
                    // Estado 4: Desaparecer (Limpiar)
                    else if (state.removalState === 4) {
                        scene.remove(mesh);
                        people.delete(id); 
                        
                        if (isGlobalRemovalActive) {
                            if (exitOrderIds.length > 0) {
                                const nextId = exitOrderIds.shift();
                                removePersonSetup(nextId); 
                            } else {
                                isGlobalRemovalActive = false;
                            }
                        }

                        updateUI(); 
                    }
                }
            });

            // Lógica global para cerrar la puerta después de su uso.
            const isDoorBeingUsed = Array.from(people.values()).some(p => p.removalState >= 3);
            
            if (!isDoorBeingUsed && mainDoorMesh && mainDoorMesh.userData.hinge.rotation.y > 0.01) {
                mainDoorMesh.userData.hinge.rotation.y = THREE.MathUtils.lerp(
                    mainDoorMesh.userData.hinge.rotation.y, 
                    0, 
                    0.03
                );
            }


            renderer.render(scene, camera);
        }
        
        // --- Funciones auxiliares sin cambios funcionales mayores ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        function createDoor() {
            const DOOR_HEIGHT = 1.9; 
            const DOOR_WIDTH = 0.9;  
            const doorGroup = new THREE.Group();
            const frameMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 }); 
            const frameThickness = 0.1;
            const topFrame = new THREE.Mesh(new THREE.BoxGeometry(DOOR_WIDTH + frameThickness * 2, frameThickness, frameThickness), frameMaterial);
            topFrame.position.set(0, DOOR_HEIGHT + frameThickness / 2, 0);
            const leftFrame = new THREE.Mesh(new THREE.BoxGeometry(frameThickness, DOOR_HEIGHT + frameThickness, frameThickness), frameMaterial);
            leftFrame.position.set(-(DOOR_WIDTH / 2) - (frameThickness / 2), DOOR_HEIGHT / 2, 0);
            const rightFrame = new THREE.Mesh(new THREE.BoxGeometry(frameThickness, DOOR_HEIGHT + frameThickness, frameThickness), frameMaterial);
            rightFrame.position.set((DOOR_WIDTH / 2) + (frameThickness / 2), DOOR_HEIGHT / 2, 0);
            doorGroup.add(topFrame, leftFrame, rightFrame);
            const doorGeometry = new THREE.BoxGeometry(DOOR_WIDTH, DOOR_HEIGHT, 0.05);
            const doorMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 }); 
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            const doorHinge = new THREE.Group();
            doorHinge.add(door);
            doorHinge.position.x = -DOOR_WIDTH / 2; 
            door.position.x = DOOR_WIDTH / 2;
            door.position.y = DOOR_HEIGHT / 2;
            door.position.z = -frameThickness/2;
            doorGroup.add(doorHinge);
            doorGroup.userData.hinge = doorHinge;
            return doorGroup;
        }
        function createDecoration() {
            const decoGroup = new THREE.Group();
            const pillarGeo = new THREE.CylinderGeometry(0.3, 0.3, 3, 16);
            const pillarMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
            const pillar = new THREE.Mesh(pillarGeo, pillarMat);
            pillar.position.set(CLUB_SIZE / 2 - 1.5, 1.5, CLUB_SIZE / 2 - 1.5); 
            decoGroup.add(pillar);
            const bulbGeo = new THREE.SphereGeometry(0.2, 12, 12);
            const bulbMat = new THREE.MeshBasicMaterial({ color: 0xffa500, transparent: true, opacity: 0.8 });
            const bulb = new THREE.Mesh(bulbGeo, bulbMat);
            bulb.position.set(CLUB_SIZE / 2 - 1.5, 3, CLUB_SIZE / 2 - 1.5);
            decoGroup.add(bulb);
            scene.add(decoGroup);
        }
        function createStreetLamp() {
            const poleHeight = 4.5;
            const poleRadius = 0.1;
            const lampColor = 0x888888;
            const poleGeo = new THREE.CylinderGeometry(poleRadius, poleRadius, poleHeight, 8);
            const poleMat = new THREE.MeshLambertMaterial({ color: lampColor });
            const pole = new THREE.Mesh(poleGeo, poleMat);
            pole.position.y = poleHeight / 2;
            const lampGroup = new THREE.Group();
            lampGroup.position.set(DOOR_POSITION.x - 4, 0, 0);
            const streetLampLight = new THREE.PointLight(0xffddaa, 2.5, 12); 
            streetLampLight.position.set(0, poleHeight + 0.2, 0); 
            const bulbGeo = new THREE.SphereGeometry(0.15, 8, 8);
            const bulbMat = new THREE.MeshBasicMaterial({ color: 0xffddaa });
            const bulb = new THREE.Mesh(bulbGeo, bulbMat);
            bulb.position.set(0, poleHeight + 0.2, 0);
            lampGroup.add(pole, streetLampLight, bulb);
            scene.add(lampGroup);
        }
        function createQueue(count) {
            const queueStartPos = new THREE.Vector3(DOOR_POSITION.x - 3.5, 0, 0.7); 
            const spacing = 1.0; 
            for (let i = 0; i < count; i++) {
                const gender = i % 2 === 0 ? 'man' : 'woman';
                const personMesh = createPerson(gender); 
                personMesh.position.set(queueStartPos.x - i * spacing, 0, queueStartPos.z);
                personMesh.rotation.y = Math.PI / 2; 
                scene.add(personMesh);
            }
        }
        function clearAllPeople() {
            if (people.size === 0 || isGlobalRemovalActive) return;
            exitOrderIds = Array.from(people.keys());
            isGlobalRemovalActive = true;
            if (exitOrderIds.length > 0) {
                const firstId = exitOrderIds.shift(); 
                removePersonSetup(firstId); 
            } 
            if (mainDoorMesh) {
                mainDoorMesh.userData.hinge.rotation.y = 0;
            }
            updateUI();
        }
        function removePerson(id) {
            if (isGlobalRemovalActive) return; 
            removePersonSetup(id);
            updateUI();
        }
        function updateUI() {
            peopleListElement.innerHTML = '';
            let currentCount = 0;
            people.forEach(state => {
                currentCount++;
                let statusText = state.isRemoving ? '(Saliendo)' : '(Presente)';
                let className = `flex justify-between items-center p-2 rounded-lg ${state.gender === 'man' ? 'bg-blue-50' : 'bg-pink-50'} border border-gray-200`;
                const isWaitingInQueue = isGlobalRemovalActive && !state.isRemoving && exitOrderIds.includes(state.id);
                if (isWaitingInQueue) {
                    statusText = '(En cola)';
                    className = `flex justify-between items-center p-2 rounded-lg ${state.gender === 'man' ? 'bg-blue-100' : 'bg-pink-100'} border border-yellow-400`;
                }
                const li = document.createElement('li');
                const name = document.createElement('span');
                name.className = 'font-semibold text-gray-700';
                name.textContent = `${state.gender === 'man' ? 'Hombre' : 'Mujer'} ${statusText}`;
                const removeButton = document.createElement('button');
                removeButton.className = 'bg-red-500 hover:bg-red-600 text-white text-xs font-bold py-1 px-3 rounded-md transition duration-150 shadow-sm disabled:bg-gray-400';
                const isDisabled = state.isRemoving || isGlobalRemovalActive;
                removeButton.textContent = isDisabled ? (state.isRemoving ? 'Saliendo...' : 'En cola...') : 'Eliminar';
                removeButton.disabled = isDisabled;
                removeButton.onclick = () => removePerson(state.id);
                li.className = className;
                li.appendChild(name);
                li.appendChild(removeButton);
                peopleListElement.appendChild(li);
            });
            countElement.textContent = currentCount;
            const clearButton = document.getElementById('clearAll');
            if (clearButton) {
                 clearButton.disabled = isGlobalRemovalActive || currentCount === 0;
                 clearButton.textContent = isGlobalRemovalActive ? 'Limpiando...' : 'Limpiar Todo';
                 if (currentCount === 0 && isGlobalRemovalActive) {
                    isGlobalRemovalActive = false;
                    clearButton.textContent = 'Limpiar Todo';
                    clearButton.disabled = false;
                 }
            }
            document.getElementById('addMan').disabled = isGlobalRemovalActive;
            document.getElementById('addWoman').disabled = isGlobalRemovalActive;
        }

        window.onload = function () {
            init();
        }
    </script>
</body>
</html>
